# *附录*

## 关于

这一部分是为了帮助学生完成书中的活动。 它包括学生为达到活动目标所要执行的详细步骤。

## 第 1 章:JavaScript、HTML 和 DOM

### 活动 1:从页面提取数据

**方案**:

1.  初始化一个变量来存储 CSV 的全部内容:
2.  查询 DOM 以找到表示每个产品的所有元素。 注意我们如何包装`Array.from`中返回的`HTMLCollection`实例，这样我们就可以像处理普通数组那样处理它:
3.  迭代找到的每个元素:
4.  在闭包内部，使用`product`元素，查询价格和单位。 使用斜杠分割字符串:

    ```
    var priceAndUnitElement = el.getElementsByTagName('span')[0];
    ```

    ```
    var priceAndUnit = priceAndUnitElement.textContent.split("/");
    ```

    ```
    var price = priceAndUnit[0].trim();
    ```

    ```
    var unit = priceAndUnit[1].trim();
    ```

5.  然后查询名称:

    ```
    var name = el.getElementsByTagName('a')[0].textContent;
    ```

6.  将所有信息附加到第 1 步中初始化的变量，用逗号分隔值。 不要忘记在每一行添加换行符:

    ```
    csv += `${name},${price},${unit}\n`;
    ```

7.  使用`console.log`函数打印包含累计数据的变量:
8.  将代码粘贴到 Chrome**Console**选项卡中; 它应该是这样的:

![Figure 1.62: Code ready to run in the Console tab ](Images/C14587_01_62.jpg)

###### 图 1.62:准备在 Console 选项卡中运行的代码

按*输入*执行代码后，您应该看到在控制台中打印的 CSV，如下所示:

![Figure 1.63: The storefront with the code and output in the Console tab ](Images/C14587_01_63.jpg)

###### 图 1.63:具有 Console 选项卡中的代码和输出的店面

### 活动 2:用 Web 组件替换标签过滤器

**方案**:

1.  首先从`Exercise07`复制代码到一个新文件夹中。
2.  创建一个名为`tags_holder.js`的新文件，并在其中添加一个扩展`HTMLElement`的类`TagsHolder`，然后定义一个新的自定义组件`tags-holder`:

    ```
    class TagsHolder extends HTMLElement {
    ```

    ```
    }
    ```

    ```
    customElements.define('tags-holder', TagsHolder);
    ```

3.  创建两个`render`方法:一个呈现基状态,另一个负责渲染标签或一些文本,指示标签选择过滤:

    ```
    render() {
    ```

    ```
      this.shadowRoot.innerHTML = `
    ```

    ```
      <link rel="stylesheet" type="text/css" href="../css/semantic.min.css" />
    ```

    【4】【5】

    ```
        <span class="tags"></span>
    ```

    ```
      </div>`;
    ```

    【显示】

    ```
    renderTagList() {
    ```

    ```
      const tagsHolderElement = this.shadowRoot.querySelector('.tags');
    ```

    ```
      tagsHolderElement.innerHTML = '';
    ```

    【病人】

    ```
      if (tags.length == 0) {
    ```

    ```
        tagsHolderElement.innerHTML = 'No filters';
    ```

    ```
        return;
    ```

    【t16.1】

    ```
      tags.forEach(tag => {
    ```

    ```
        const tagEl = document.createElement('span');
    ```

    ```
        tagEl.className = "ui label orange";
    ```

    ```
        tagEl.addEventListener('click', () => this.triggerTagClicked(tag));
    ```

    ```
        tagEl.innerHTML = tag;
    ```

    ```
        tagsHolderElement.appendChild(tagEl);
    ```

    ```
      });
    ```

    ```
    }
    ```

4.  在构造函数中，调用`w`，将组件附加到影子根，初始化所选标签列表，并同时调用`render`方法:
5.  ```
    get selectedTags() {
    ```

    ```
      return this._selectedTags.slice(0);
    ```

    ```
    }
    ```

6.  创建两个触发方法:一个触发改变事件,一个事件触发`tag-clicked`:

    ```
    triggerChanged(tag) {
    ```

    ```
      const event = new CustomEvent('changed', { bubbles: true });
    ```

    ```
      this.dispatchEvent(event);
    ```

    【4】【5】

    ```
      const event = new CustomEvent('tag-clicked', {
    ```

    ```
        bubbles: true,
    ```

    【显示】

    ```
      });
    ```

    ```
      this.dispatchEvent(event);
    ```

    ```
    }
    ```

7.  创建两个`mutator`方法:`addTag`和`removeTag`。 这些方法接收标记名，并在选定的标记列表中添加标记(如果不存在)，或删除标记(如果存在)。 如果列表修改,触发`changed`事件和调用该方法来重新呈现的列表标签:

    ```
    addTag(tag) {
    ```

    【5】

    ```
        this._selectedTags.push(tag);
    ```

    ```
        this._selectedTags.sort();
    ```

    【显示】

    ```
        this.triggerChanged();
    ```

    ```
      }
    ```

    ```
    }
    ```

    【病人】

    ```
      const index = this._selectedTags.indexOf(tag);
    ```

    ```
      if (index >= 0) {
    ```

    ```
        this._selectedTags.splice(index, 1);
    ```

    【t16.1】

    ```
        this.triggerChanged();
    ```

    ```
      }
    ```

    ```
    }
    ```

8.  In the HTML, replace the existing code with the new component. Remove the following lines:

    ```
    <div class="item">
    ```

    ```
      Filtered by tags: <span class="tags"></span>
    ```

    ```
    </div>
    ```

    ```
    And add:
    ```

    ```
    <tags-holder class="item"></tags-holder>
    ```

    ```
    Also add:
    ```

    ```
    <script src="tags_holder.js"></script>
    ```

    #### 请注意

    你可以在 GitHub 上的[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html)上看到最终的 HTML。

9.  In `filter_and_search.js`, do the following:

    在顶部，创建一个对`tags-holder`组件的引用:

    ```
    const filterByTagElement = document.querySelector('tags-holder');
    ```

    添加事件监听器来处理`changed`和`tag-clicked`事件:

    ```
    filterByTagElement.addEventListener('tag-clicked', (e) => filterByTagElement.removeTag(e.detail.tag));
    ```

    ```
    filterByTagElement.addEventListener('changed', () => applyFilters());
    ```

    删除以下函数和对它们的所有引用:`createTagFilterLabel`和`updateTagFilterList`。

    在`filterByTags`功能上，用`filterByTagElement.selectedTags`代替`tagsToFilterBy`。

    在`addTagFilter`方法中，将`tagsToFilterBy`的引用替换为`filterByTagElement.addTag`。

## 第 2 章:Node.js 和 npm

### Activity 3: Creating a npm Package to Parse HTML

**方案**:

1.  在一个空文件夹中，使用 npm 创建一个新包。 您可以使用所有的默认值选项:

    ```
    $ npm init
    ```

    ```
    This utility will walk you through creating a package.json file.
    ```

    ```
    It only covers the most common items, and tries to guess sensible defaults.
    ```

    ```
    See 'npm help json' for definitive documentation on these fields and exactly what they do.
    ```

    【4】【5】

    ```
    package name: (Activity03) 
    ```

    ```
    version: (1.0.0) 
    ```

    【显示】

    ```
    entry point: (index.js) 
    ```

    ```
    test command: 
    ```

    ```
    git repository: 
    ```

    【病人】

    ```
    author: 
    ```

    ```
    license: (ISC) 
    ```

    ```
    About to write to .../Lesson02/Activity03/package.json:
    ```

    【t16.1】

    ```
      "name": "Activity03",
    ```

    ```
      "version": "1.0.0",
    ```

    ```
      "description": "",
    ```

    ```
      "main": "index.js",
    ```

    ```
      "scripts": {
    ```

    ```
        "test": "echo \"Error: no test specified\" && exit 1"
    ```

    ```
      },
    ```

    ```
      "author": "",
    ```

    ```
      "license": "ISCs"
    ```

    ```
    }
    ```

    ```
    Is this OK? (yes)
    ```

2.  安装`cheerio`，运行`npm install`。

    ```
    $ npm install cheerio
    ```

    ```
    npm notice created a lockfile as package-lock.json. You should commit this file.
    ```

    ```
    npm WARN Activity03@1.0.0 No description
    ```

    ```
    npm WARN Activity03@1.0.0 No repository field.
    ```

    ```
    + cheerio@1.0.0-rc.3added 19 packages from 45 contributors and audited 34 packages in 6.334s
    ```

    ```
    found 0 vulnerabilities
    ```

3.  在这个文件夹中，创建一个名为`index.js`的文件，并添加以下内容:
4.  创建一个变量，从 GitHub 的示例代码存储 HTML([https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html))。 创建多行字符串时，可以使用反引号:

    ```
    const html = `
    ```

    ```
    <html>
    ```

    ```
      <head>
    ```

    ```
        <title>Sample Page</title>
    ```

    ```
      </head>
    ```

    ```
      <body>
    ```

    ```
        <p>This is a paragraph.</p>
    ```

    ```
        <div>
    ```

    ```
          <p>This is a paragraph inside a div.</p>
    ```

    ```
        </div>
    ```

    ```
        <button>Click me!</button>
    ```

    ```
      </body>
    ```

    ```
    </html>
    ```

    ```
    `;
    ```

5.  解析 HTML 并将其传递给 cheerio。 在 cheerio 的示例中，您将看到他们将解析的变量命名为“`$`”(美元符号)。 这是 jQuery 世界中使用的一个旧约定。 这是它的样子:

    ```
    const $ = cheerio.load(html);
    ```

6.  Now, we can use that variable to manipulate the HTML. To start, we will add a paragraph to the page with some text in it:

    ```
    $('div').append('<p>This is another paragraph.</p>');
    ```

    我们还可以使用 CSS 选择器查询 HTML，类似于我们在*第一章中所做的，JavaScript, HTML 和 DOM*。 让我们查询所有段落并将它们的内容打印到控制台。 请注意，cheerio 元素的行为与 DOM 元素并不完全相同，但它们非常相似。

7.  使用`firstChild`属性查找每个段落的第一个节点并打印其内容，假设它是 text 元素:
8.  Lastly, inside `index.js`, print the manipulated HTML to the console by calling the `html` function:

    ```
    console.log($.html());
    ```

    现在，你可以通过从 Node.js 调用它来运行你的应用程序:

![Figure 2.7: Calling the application from node.js ](Images/C14587_02_07.jpg)

###### 图 2.7:从 Node.js 调用应用程序

## 第 3 章:Node.js api 和 Web 抓取

### 活动 4 从店面抓取产品和价格

**溶液**

1.  使用本章中

    ```
    $ node Lesson03/Activity04/
    ```

    ```
    Static resources from /path/to/repo/Lesson03/Activity04/static
    ```

    ```
    Loaded 21 products...
    ```

    ```
    Go to: http://localhost:3000
    ```

    的代码，启动动态服务器来服务前端应用程序。
2.  在一个新的终端上，创建一个新的`npm`包，安装`jsdom`，并创建`index.js`入口文件:

    ```
    $ npm init
    ```

    ```
    ...
    ```

    ```
    $ npm install jsdom
    ```

    ```
    + jsdom@15.1.1
    ```

    ```
    added 97 packages from 126 contributors and audited 140 packages in 12.278s
    ```

    ```
    found 0 vulnerabilities
    ```

3.  调用`require()`方法来加载项目中需要的所有模块:
4.  向`http://localhost:3000`发起 HTTP 请求:

    ```
    const page = 'http://localhost:3000';
    ```

    ```
    console.log(`Downloading ${page}...`);
    ```

    ```
    const request = http.get(page, (response) => {
    ```

5.  ```
    if (response.statusCode != 200) {
    ```

    ```
      console.error(`Error while fetching page ${page}: ${response.statusCode}`);
    ```

    ```
      console.error(`Status message: ${response.statusMessage}`);
    ```

    ```
      return;
    ```

    ```
    }
    ```

    ```
    let content = '';
    ```

    ```
    response.on('data', (chunk) => content += chunk.toString());
    ```

6.  In the `close` event, parse the HTML using `JSDOM`:

    ```
    response.on('close', () => {
    ```

    ```
      console.log('Download finished.');
    ```

    ```
      const document = new JSDOM(content).window.document;
    ```

    ```
      writeCSV(extractProducts(document));
    ```

    ```
    });
    ```

    上述回调函数调用两个函数:`extractProducts`和`writeCSV`。 下面的步骤将描述这些函数。

7.  使用`extractProducts`函数查询 DOM 并从中获取产品信息。 它将所有的产品存储在一个数组,返回最后:

    ```
    function extractProducts(document) {
    ```

    ```
      const products = [];
    ```

    ```
      console.log('Parsing product data...');
    ```

    【4】【5】

    ```
          process.stdout.write('.');
    ```

    ```
          const priceAndUnitElement = el.getElementsByTagName('span')[0];
    ```

    【显示】

    ```
         const price = priceAndUnit[0].trim().substr(1);
    ```

    ```
          const unit = priceAndUnit[1].trim();
    ```

    ```
          const name = el.getElementsByTagName('a')[0].textContent;
    ```

    【病人】

    ```
        });
    ```

    ```
      console.log();
    ```

    ```
      console.log(`Found ${products.length} products.`);
    ```

    【t16.1】

    ```
    }
    ```

8.  使用`writeCSV`功能，打开 CSV 文件进行写操作，保证没有错误:

    ```
    function writeCSV(products) {
    ```

    ```
     const fileName = 'products.csv';
    ```

    ```
      console.log(`Writing data to ${fileName}...`);
    ```

    ```
      fs.open(fileName, 'w', (error, fileDescriptor) => {
    ```

    ```
        if (error != null) {
    ```

    ```
          console.error(`Can not write to file: ${fileName}`, error);
    ```

    ```
          return;
    ```

    ```
        }
    ```

9.  ```
        // Write header
    ```

    ```
        fs.writeSync(fileDescriptor, 'name,price,unit\n');
    ```

    ```
        // Write content
    ```

    ```
        products.forEach((product) => {
    ```

    ```
          const line = `${product.name},${product.price},${product.unit}\n`;
    ```

    ```
          fs.writeSync(fileDescriptor, line);
    ```

    ```
        });
    ```

    ```
        console.log('Done.');
    ```

    ```
      });
    ```

    ```
    }
    ```

10.  在新建的终端上运行应用程序:

    ```
    $ node .
    ```

    ```
    Downloading http://localhost:3000...
    ```

    ```
    Download finished.
    ```

    ```
    Parsing product data...
    ```

    ```
    .....................
    ```

    ```
    Found 21 products.
    ```

    ```
    Writing data to products.csv...
    ```

## 第四章:使用 Node.js 的 RESTful api

### 活动 5:为键盘门锁创建 API 端点

**溶液**

1.  创建一个新的项目文件夹，并将其更改为以下目录:
2.  初始化`npm`项目，并安装`express`、`express-validator`、`jwt-simple`。 创建目录:`routes`:

    ```
    npm init -y
    ```

    ```
    npm install --save express express-validator jwt-simple
    ```

    ```
    mkdir routes
    ```

3.  创建一个`config.js`文件，就像你在*练习 21，设置一个终端需要身份验证*中所做的那样。 其中应该包含一个随机生成的秘密值:

    ```
    let config = {};
    ```

    ```
    // random value below generated with command: openssl rand -base64 32
    ```

    ```
    config.secret = "cSmdV7Nh4e3gIFTO0ljJlH1f/F0ROKZR/hZfRYTSO0A=";
    ```

    ```
    module.exports = config;
    ```

4.  创建`routes/check-in.js`文件以创建签入路由。 :

    ```
    const express = require('express');
    ```

    ```
    const jwt = require('jwt-simple');
    ```

    ```
    const { check, validationResult } = require('express-validator/check');
    ```

    ```
    const router = express.Router();
    ```

    ```
    // import our config file and get the secret value
    ```

    ```
    const config = require('../config');
    ```

5.  创建第二个路由文件`routes/lock.js`。 开始所需的文件被导入库和模块,并创建一个空数组来保存我们的有效密码:

    ```
    const express = require('express');
    ```

    ```
    const app = express();
    ```

    ```
    const { check, validationResult } = require('express-validator/check');
    ```

    【4】【5】

    ```
    const path = require('path');
    ```

    ```
    const fs = require('fs');
    ```

    【显示】

    ```
    const createError = require('http-errors');
    ```

    ```
    // Import library for working with JWT tokens
    ```

    ```
    const jwt = require('jwt-simple');
    ```

    【病人】

    ```
    const config = require('./../config');
    ```

    ```
    const secret = config.secret;
    ```

    ```
    // Create an array to keep track of valid passcodes
    ```

    【t16.1】
6.  创建一个`/code`的`GET`路线需要`name`的价值,这是代码之后继续在前面一步`routes/lock.js`文件:

    ```
    router.get(['/code'], [
    ```

    【5】

    ```
      ],
    ```

    ```
      (req, res) => {
    ```

    【显示】

    ```
        codeObj.guest = req.body.name;
    ```

    ```
        // Check that authorization header was sent
    ```

    ```
        if (req.headers.authorization) {
    ```

    【病人】

    ```
          try {
    ```

    ```
            req._guest = jwt.decode(token, secret);
    ```

    ```
          } catch {
    ```

    【t16.1】

    ```
          }
    ```

    ```
          // If the decoded object guest name property
    ```

    ```
          if (req._guest.name) {
    ```

    ```
            codeObj.creator = req._guest.name;
    ```

7.  在`routes/lock.js`中创建另一条路由。 这个将用于`/open`，并需要一个四位数的代码，将对`passCodes`数组进行检查，以确定它是否有效。 下面这条路线,确保出口`router`,所以它可以用在`server.js`:

    ```
    router.post(['/open'], [
    ```

    ```
        check('code').isLength({ min: 4, max: 4 })
    ```

    ```
      ],
    ```

    【显示】

    ```
        let code = passCodes.findIndex(obj => {
    ```

    ```
          return obj.code === req.body.code;
    ```

    ```
        });
    ```

    【病人】

    ```
          passCodes.splice(code, 1);
    ```

    ```
          res.json({ message: 'Pass code is valid, door opened.' });
    ```

    ```
        } else {
    ```

    【t16.1】

    ```
        }
    ```

    ```
    });
    ```

    ```
    // Export route so it is available to import
    ```

    ```
    module.exports = router;
    ```

8.  创建主文件，我们的路由将在`server.js`中使用。

    ```
    const express = require('express');
    ```

    ```
    const app = express();
    ```

    ```
    // Import path and file system libraries for importing our route files
    ```

    ```
    const path = require('path');
    ```

    ```
    const fs = require('fs');
    ```

    ```
    // Import library for handling HTTP errors
    ```

    ```
    const createError = require('http-errors');
    ```

    ```
    // Tell express to enable url encoding
    ```

    ```
    app.use(express.urlencoded({extended: true}));
    ```

    ```
    app.use(express.json());
    ```

9.  接下来,在`server.js`,在前面的代码中,导入两个路线,实现一个`404`笼统,并告诉 API 来监听端口`3000`:

    ```
    // Import our index route
    ```

    【4】【5】

    ```
    app.use('/check-in', checkIn);
    ```

    ```
    app.use('/lock', lock);
    ```

    【显示】

    ```
    app.use(function(req, res, next) {
    ```

10.  最后，我们将测试 API，以确保它是正确的。 从运行你的程序开始:

    ```
    npm start
    ```

11.  With the program running, open a second Terminal window and use the `/check-in` endpoint to get a JWT and save the value as `TOKEN`. Then, echo that value to ensure it was successful:

    ```
    TOKEN=$(curl -sd "name=john" -X POST http://localhost:3000/check-in \
    ```

    ```
      | jq -r ".token")
    ```

    ```
    echo $TOKEN
    ```

    你应该得到一长串字母和数字，像下面:

    ![Figure 4.24: Getting TOKEN from the check-in endpoint ](Images/C14587_04_24.jpg)

    ###### 图 4.24:从签入端点获取 TOKEN

12.  Next, we will use our JWT to use the `/lock/code` endpoint to get a one-time passcode for Sarah:

    ```
    curl -sd "name=sarah" -X GET \
    ```

    ```
      -H "Authorization: Bearer ${TOKEN}" \
    ```

    ```
      http://localhost:3000/lock/code \
    ```

    ```
      | jq
    ```

    你应该返回一个包含消息和四位数代码的对象，如下所示:

    ![Figure 4.25: A four-digit one-time code ](Images/C14587_04_25.jpg)

    ###### 图 4.25:一个四位数的一次性代码

13.  To ensure the code works, send it to the `/lock/open` endpoint. We will send the following command once, expecting it to be successful. We will then send the same command a second time, expecting it to fail since each code is used only once. Run the following twice:

    ```
    # IMPORTANT: Make sure to replace 4594, with your specific passcode!
    ```

    ```
    curl -sd "code=4594" -X POST \
    ```

    ```
      http://localhost:3000/lock/open \
    ```

    ```
      | jq
    ```

    运行两次以上的命令应该会返回如下内容:

![Figure 4.26: Running the command twice results in an error ](Images/C14587_04_26.jpg)

###### 图 4.26:两次执行命令导致错误

如果结果与上图所示相同，那么您已经成功地完成了该活动。

## 第五章:模块化 JavaScript

### 活动 6:创建闪光灯模式的灯泡

**方案**:

1.  安装预设的`babel-cli`和`babel`作为开发依赖:

    ```
    npm install --save-dev webpack webpack-cli @babel/core @babel/cli @babel/preset-env
    ```

2.  添加一个名为`.babelrc`的文件到根目录。 在其中，我们将告诉巴别塔使用预置设置:

    ```
    {
    ```

    ```
      "presets": ["@babel/preset-env"]
    ```

    ```
    }
    ```

3.  ```
    const path = require("path");
    ```

    ```
    module.exports = {
    ```

    ```
      mode: 'development',
    ```

    ```
      entry: "./build/js/viewer.js",
    ```

    ```
      output: {
    ```

    ```
        path: path.resolve(__dirname, "build"),
    ```

    ```
        filename: "bundle.js"
    ```

    ```
      }
    ```

    ```
    };
    ```

4.  创建一个新文件`js/flashingLight.js`。 这应该作为一个扩展`Light`的空白 ES6 组件开始。 在构造函数中,我们将包括`state`、`brightness`,

    ```
    import Light from './light.js';
    ```

    和`flashMode`:

    ```
    let privateVars = new WeakMap();
    ```

    ```
    class FlashingLight extends Light {
    ```

    【显示】

    ```
        super(state, brightness);
    ```

    ```
        let info = {"flashMode": flashMode};
    ```

    ```
        privateVars.set(this, info);
    ```

    【病人】

    ```
          this.startFlashing();
    ```

    ```
        }
    ```

    ```
      }
    ```

5.  为对象添加 setter 方法，该方法也将触发 stop 和 start flash 方法。

    ```
      setFlashMode(flashMode) {
    ```

    ```
        let info = privateVars.get(this);
    ```

    ```
        info.flashMode = checkStateFormat(flashMode);
    ```

    【4】【5】

    ```
          this.startFlashing();
    ```

    ```
        } else {
    ```

    【显示】

    ```
        }
    ```

    ```
      }
    ```

6.  ```
      getFlashMode() {
    ```

    ```
        let info = privateVars.get(this);
    ```

    ```
        return info.flashMode;
    ```

    ```
      }
    ```

7.  创建一个引用父类的`lightSwitch()`函数的`startFlashing`函数。 这一步很棘手，因为我们必须将其绑定到`setInterval`:

    ```
      startFlashing() {
    ```

    ```
        let info = privateVars.get(this);
    ```

    ```
        info.flashing = setInterval(this.toggle.bind(this),5000);
    ```

    ```
      }
    ```

8.  ```
      stopFlashing() {
    ```

    ```
        let info = privateVars.get(this);
    ```

    ```
        clearInterval(info.flashing);
    ```

    ```
      }
    ```

9.  作为`flashingLight.js`的最后一部分，关闭类并导出:

    ```
    }
    ```

    ```
    export default FlashingLight;
    ```

10.  ```
    button.onclick = function () {
    ```

    ```
      new FlashingLight(true, slider.value, true);
    ```

    ```
    }
    ```

    ```
    button.onclick = function () {
    ```

    ```
    }
    ```

    ```
    button.onclick = function () {
    ```

    ```
      new FlashingLight(true, slider.value, true);
    ```

    ```
    }
    ```

11.  使用 npm 运行`build`函数编译代码:
12.  打开`build/index.html`，设置脚本位置为`bundle.js`:

    ```
    <script src="bundle.js" type="module"></script>
    ```

13.  要测试一切是否正常工作，请运行`npm start`并在浏览器中打开`localhost:8000`。 点击`build`按钮创建一个完整的灯光页面。 如果一切都做对了，你应该会看到每盏灯以 5 秒的间隔闪烁:

![Figure 5.20: Lightbulbs with flash mode ](Images/C14587_05_20.jpg)

###### 图 5.20:有闪光模式的灯泡

## 第六章:代码质量

### 活动 7:put It All Together

**溶液**

1.  安装测试练习中列出的开发人员依赖项(`eslint`、`prettier`、`eslint-config-airbnb-base`、`eslint-config-prettier`、`eslint-plugin-jest`和`eslint-plugin-import`):

    ```
    npm install --save-dev eslint prettier eslint-config-airbnb-base eslint-config-prettier eslint-plugin-jest eslint-plugin-import
    ```

2.  添加一个配置文件`eslint`,`.eslintrc`,它包含以下几点:

    ```
    {
    ```

    ```
     "extends": ["airbnb-base", "prettier"],
    ```

    【4】【5】

    ```
        "sourceType": "module"
    ```

    ```
      },
    ```

    【显示】

    ```
        "browser": true,
    ```

    ```
        "node": true,
    ```

    ```
        "es6": true,
    ```

    【病人】

    ```
        "jest": true
    ```

    ```
      },
    ```

    ```
      "plugins": [],
    ```

    【t16.1】

    ```
        "no-unused-vars": [
    ```

    ```
          "error",
    ```

    ```
          {
    ```

    ```
            "vars": "local",
    ```

    ```
            "args": "none"
    ```

    ```
          }
    ```

    ```
        ],
    ```

    ```
        "no-plusplus": "off",
    ```

    ```
      }
    ```

    ```
    }
    ```

3.  添加一个。 `prettierignore`文件:

    ```
    node_modules
    ```

    ```
    build
    ```

    ```
    dist
    ```

4.  在您的`package.json`文件中添加`lint`命令:
5.  打开`assignment`文件夹，安装使用 Jest 使用 Puppeteer 的开发依赖项:
6.  修改您的`package.json`文件，添加一个选项告诉 Jest 使用`jest-puppeteer`预设:

    ```
      "jest": {
    ```

    ```
        "preset": "jest-puppeteer"
    ```

    ```
      },
    ```

7.  向`package.json`添加`test`脚本，运行`jest`:

    ```
      "scripts": {
    ```

    ```
        "start": "http-server",
    ```

    ```
        "lint": "prettier --write js/*.js && eslint js/*.js",
    ```

    ```
        "test": "jest"
    ```

    ```
      },
    ```

8.  创建一个`jest-puppeteer.config.js`文件，包含以下内容:

    ```
    module.exports = {
    ```

    ```
      server: {
    ```

    ```
        command: 'npm start',
    ```

    ```
        port: 8080,
    ```

    ```
      },
    ```

    ```
    }
    ```

9.  创建一个测试文件包含以下`__tests__/calculator.js`:

    ```
    describe('Calculator', () => {
    ```

    ```
      beforeAll(async () => {
    ```

    ```
        await page.goto('http://localhost:8080');
    ```

    【4】【5】

    ```
        const seven = await page.$("#seven");
    ```

    ```
        const multiply = await page.$("#multiply");
    ```

    【显示】

    ```
        const clear = await page.$("#clear");
    ```

    ```
        await seven.click();
    ```

    ```
        await seven.click();
    ```

    【病人】

    ```
        await multiply.click();
    ```

    ```
        await seven.click();
    ```

    ```
        await seven.click();
    ```

    【t16.1】

    ```
        await equals.click();
    ```

    ```
        const result = await page.$eval('#screen', e => e.innerText);
    ```

    ```
        expect(result).toMatch('603729');
    ```

    ```
        await clear.click();
    ```

    ```
      })
    ```

    ```
      it('Check that 3.14 divided by 2 is 1.57', async () => {
    ```

    ```
        const one = await page.$("#one");
    ```

    ```
        const two = await page.$("#two");
    ```

    ```
        const three = await page.$("#three");
    ```

    ```
        const four = await page.$("#four");
    ```

    ```
        const divide = await page.$("#divide");
    ```

    ```
        const decimal = await page.$("#decimal");
    ```

    ```
        const equals = await page.$("#equals");
    ```

    ```
        await three.click();
    ```

    ```
        await decimal.click();
    ```

    ```
        await one.click();
    ```

    ```
        await four.click();
    ```

    ```
        await divide.click();
    ```

    ```
        await two.click();
    ```

    ```
        await equals.click();
    ```

    ```
        const result = await page.$eval('#screen', e => e.innerText);
    ```

    ```
        expect(result).toMatch('1.57');
    ```

    ```
      })
    ```

    ```
    })
    ```

10.  在`.huskyrc`上创建一个 Husky 文件，包含以下内容:

    ```
    {
    ```

    ```
      "hooks": {
    ```

    ```
        "pre-commit": "npm run lint && npm test"
    ```

    ```
      }
    ```

    ```
    }
    ```

11.  Install `husky` as a developer dependency by running `npm install --save-dev husky`:

    ![Figure 6.19: Installing Husky ](Images/C14587_06_19.jpg)

    ###### 图 6.19:安装 Husky

12.  Ensure that tests are working correctly using the `npm test` command:

    ```
    npm test
    ```

    如下图所示，这将返回两次检测的阳性结果:

![Figure 6.20: Showing the positive result of two tests ](Images/C14587_06_20.jpg)

###### 图 6.20:显示两次测试的阳性结果

通过提交测试，确保 Git 挂钩和检测工作正常。

## 第七章:高级 JavaScript

### 活动 8:创建用户跟踪器

**溶液**

1.  Open the `Activity08.js` file and define `logUser`. It will add the user to the `userList` argument. Make sure no duplicates are added:

    ```
    function logUser(userList, user) {
    ```

    ```
    if(!userList.includes(user)) {
    ```

    ```
    userList.push(user);
    ```

    ```
    }
    ```

    ```
    }
    ```

    这里，我们使用了一个`includes`方法来检查用户是否已经存在。 如果他们没有，他们将被加入我们的名单。

2.  Define `userLeft`. It will remove the user from the `userList` argument. If the user doesn't exist, it will do nothing:

    ```
    function userLeft(userList, user) {
    ```

    ```
    const userIndex = userList.indexOf(user);
    ```

    ```
    if (userIndex >= 0) {
    ```

    ```
        userList.splice(userIndex, 1);
    ```

    ```
    }
    ```

    ```
    }
    ```

    在这里，我们使用`indexOf`来获取我们想要删除的用户的当前索引。 如果道具不存在，`indexOf`将会`return –1`，所以我们只使用`splice`移除存在的道具。

3.  定义`numUsers`，返回当前列表中的用户数量:

    ```
    function numUsers(userList) {
    ```

    ```
    return userLeft.length;
    ```

    ```
    }
    ```

4.  Define a function called `runSite`. We will create a `users` array and call the function we declared previously to test our implementation. We will also invoke the function afterward:

    ```
    function runSite() {
    ```

    ```
        // Your user list for your website
    ```

    ```
        const users = [];
    ```

    ```
        // Simulate user viewing your site
    ```

    ```
        logUser(users, 'user1');
    ```

    ```
        logUser(users, 'user2');
    ```

    ```
        logUser(users, 'user3');
    ```

    ```
        // User left your website
    ```

    ```
        userLeft(users, 'user2');
    ```

    ```
        // More user goes to your website
    ```

    ```
        logUser(users, 'user4');
    ```

    ```
        logUser(users, 'user4');
    ```

    ```
        logUser(users, 'user5');
    ```

    ```
        logUser(users, 'user6');
    ```

    ```
        // More user left your website
    ```

    ```
        userLeft(users, 'user1');
    ```

    ```
        userLeft(users, 'user4');
    ```

    ```
        userLeft(users, 'user2');
    ```

    ```
        console.log('Current user: ', users.join(', '));
    ```

    ```
    }
    ```

    ```
    runSite();
    ```

    定义函数后，运行前面的代码将返回以下输出:

![Figure 7.62: Output of running log_users.js ](Images/C14587_07_62.jpg)

###### 图 7.62:运行 log_users.js 的输出

### 活动 9:使用 JavaScript 数组和类创建学生管理器

**溶液**

1.  Create a `School` class that includes all the student's information:

    ```
    class School {
    ```

    ```
    constructor() {
    ```

    ```
        this.students = [];
    ```

    ```
    }
    ```

    ```
    }
    ```

    在`School`构造函数中，我们简单地初始化一个学生列表。 稍后，我们将向这个列表添加新学生。

2.  Create a `Student` class that includes all the relevant information about the student:

    ```
    class Student {
    ```

    ```
    constructor(name, age, gradeLevel) {
    ```

    ```
        this.name = name;
    ```

    ```
        this.age = age;
    ```

    ```
        this.gradeLevel = gradeLevel;
    ```

    ```
        this.courses = [];
    ```

    ```
    }
    ```

    ```
    }
    ```

    在学生的`constructor`中，我们存储了课程列表，以及学生的`age`、`name`和`gradeLevel`。

3.  Create a `Course` class that will include information about the course's `name` and `grade`:

    ```
    class Course {
    ```

    ```
    constructor(name, grade) {
    ```

    ```
        this.name = name;
    ```

    ```
        this.grade = grade;
    ```

    ```
    }
    ```

    ```
    }
    ```

    课程构造器只是简单地将课程名称和成绩存储在`object`中。

4.  在`School`类创建`addStudent`:

    ```
    addStudent(student) {
    ```

    ```
    this.students.push(student);
    ```

    ```
    }
    ```

5.  在`School`类创建`findByGrade`:

    ```
    findByGrade(gradeLevel) {
    ```

    ```
        return this.students.filter((s) => s.gradeLevel === gradeLevel);
    ```

    ```
    }
    ```

6.  在`School`类创建`findByAge`:

    ```
    findByAge(age) {
    ```

    ```
    return this.students.filter((s) => s.age === age);
    ```

    ```
    }
    ```

7.  在`School`类创建`findByName`:

    ```
    findByName(name) {
    ```

    ```
    return this.students.filter((s) => s.name === name);
    ```

    ```
    }
    ```

8.  In the `Student` class, create a `calculateAverageGrade` method for calculating the average grade of the student:

    ```
    calculateAverageGrade() {
    ```

    ```
    const totalGrades = this.courses.reduce((prev, curr) => prev + curr.grade, 0);
    ```

    ```
    return (totalGrades / this.courses.length).toFixed(2);
    ```

    ```
    }
    ```

    在`calculateAverageGrade`方法中，我们使用数组 reduce 来获取我们学生所有班级的总成绩。 然后，我们用这个除以课程列表中的课程数。

9.  In the `Student` class, create a method called `assignGrade`, which will assign a number grade for a course the student is taking:

    ```
    assignGrade(name, grade) {
    ```

    ```
    this.courses.push(new Course(name, grade))
    ```

    ```
    }
    ```

    您应该在`student_manager.js`文件中完成您的工作，并修改提供的方法模板。 如果你正确地实现了所有内容，你应该看到**TEST PASSED**消息:

![Figure 7.63: Screenshot showing the TEST PASSED message ](Images/C14587_07_63.jpg)

###### 图 7.63:显示 TEST PASSED 消息的屏幕截图

### Activity 10: Refactoring Functions to Use Modern JavaScript FeaturesActivity 10: Refactoring Functions to Use Modern JavaScript Features

**溶液**

1.  Open `Activity03.js`; it should contain various functions written in legacy JavaScript. When you run `Activity03.js` using Node.js, you should see the following output:

    ![Figure 7.64: Output after running Lesson7-activity.js ](Images/C14587_07_64.jpg)

    ###### 图 7.64:运行 Lesson7-activity.js 后的输出

2.  您需要重构`itemExist`，使用`includes`数组:

    ```
    function itemExist(array, item) {
    ```

    ```
        return array.includes(item);
    ```

    ```
    }
    ```

    ```
    In pushUnique we will use array push to add new item to the bottom
    ```

    ```
    function pushUnique(array, item) {
    ```

    ```
        if (!itemExist(array, item)) {
    ```

    ```
            array.push(item);
    ```

    ```
        }
    ```

    ```
    }
    ```

3.  在`createFilledArray`中，我们将使用`array.fill`来填充一个初始值:

    ```
    function createFilledArray(size, init) {
    ```

    ```
        const newArray = new Array(size).fill(init);
    ```

    ```
        return newArray;
    ```

    ```
    }
    ```

    ```
    In removeFirst we will use array.shift to remove the first item
    ```

    ```
    function removeFirst(array) {
    ```

    ```
        return array.shift();
    ```

    ```
    }
    ```

4.  在`removeLast`中，我们将用`array.pop`去掉最后一项:

    ```
    function removeLast(array) {
    ```

    ```
        return array.pop();
    ```

    ```
    }
    ```

    ```
    In cloneArray we will use spread operation to make clone for our array
    ```

    ```
    function cloneArray(array) {
    ```

    ```
        return […array];
    ```

    ```
    }
    ```

5.  We will refactor our `Food` class using the `ES6` class:

    ```
    class Food {
    ```

    ```
        constructor(type, calories) {
    ```

    ```
            this.type = type;
    ```

    ```
            this.calories = calories;
    ```

    ```
        }
    ```

    ```
        getCalories() {
    ```

    ```
            return this.calories;
    ```

    ```
        }
    ```

    ```
    }
    ```

    当你完成了重构并运行现有代码后，你应该会看到相同的输出:

![Figure 7.65: Output showing the TEST PASSED message ](Images/C14587_07_65.jpg)

###### 图 7.65:显示 TEST PASSED 消息的输出

## 第八章:异步编程

### 活动 11:使用回调来接收结果

**方案**:

1.  创建一个以`id`和`callback`为参数的`calculate`函数:
2.  We will first call `getUsers` to get all of the users. This will give us the address we need:

    ```
    function calculate(id, callback) {
    ```

    ```
    clientApi.getUsers((error, result) => {
    ```

    ```
    if (error) { return callback(error); }
    ```

    ```
    const currentUser = result.users.find((user) => user.id === id);
    ```

    ```
    if (!currentUser) { return callback(new Error('user not found')); }
    ```

    ```
    });
    ```

    ```
      }
    ```

    在这里，我们获取所有用户，然后应用`find`方法到`user`，从列表中找到我们想要的用户。 如果该用户不存在，则调用`callback`函数并返回`User not found`错误。

3.  Call `getUsage` to get the user's usage:

    ```
    clientApi.getUsage(id, (error, usage) => {
    ```

    ```
    if (error) { return callback(error); }
    ```

    ```
      });
    ```

    然后，我们需要将对`getUsage`的调用放在`getUsers`的回调函数中，以便在我们完成`getUsers`调用后，它将运行。 在这里，回调函数将被一个数字列表调用，这将是用法。 如果从`getUsage`收到一个错误，我们也将用错误对象调用回调函数。

4.  Finally, call `getRate` to get the rate of the user we are doing the calculation for:

    ```
    clientApi.getRate(id, (error, rate) => {
    ```

    ```
    if (error) { return callback(error); }
    ```

    ```
    let totalUsage = 0;
    ```

    ```
    for (let i = 0; i < usage.length; i++) {
    ```

    ```
        totalUsage += usage[i];
    ```

    ```
    }
    ```

    ```
    callback(null, {
    ```

    ```
    id,
    ```

    ```
    address: currentUser.address,
    ```

    ```
    due: rate * totalUsage
    ```

    ```
    });
    ```

    ```
    });
    ```

    我们将把这个调用放到`getUsage`的回调函数中。 这将为我们需要的所有信息创建一个嵌套链请求。 最后，我们将使用正在计算的信息调用回调函数。 对于最终的到期金额，我们使用数组 reduce 来计算该用户的总使用量，然后将其乘以速率来得到最终到期金额。

5.  When the function is completed, invoke it using an existing ID, as in the following code:

    ```
    calculate('DDW2AU', (error, result) => {
    ```

    ```
        console.log(error, result);
    ```

    ```
    });
    ```

    你应该看到这样的输出:

    ![Figure 8.43: Invoking the function using an existing ID ](Images/C14587_08_43.jpg)

    ###### 图 8.43:使用现有 ID 调用函数

6.  Invoke the function using an ID that doesn't exist:

    ```
    calculate('XXX', (error, result) => {
    ```

    ```
        console.log(error, result);
    ```

    ```
    });
    ```

    你应该看到下面的输出和返回的错误:

![Figure 8.44: Invoking a function using an ID that doesn’t exist ](Images/C14587_08_44.jpg)

###### 图 8.44:使用不存在的 ID 调用函数

### Activity 12: Refactor the Bill Calculator Using Async and Await

**溶液**

1.  创建`calculate`功能为`async`功能:

    ```
    async function calculate(id) {
    ```

    ```
    }
    ```

2.  Use `await` to call `getUsers` to get the resolved result in `users`:

    ```
    const users = await clientApi.getUsers();
    ```

    ```
    const currentUser = users.users.find((user) => user.id === id);
    ```

    当我们使用`await`关键字时，我们必须使用`async`函数。 关键字`await`将打破我们的程序的控制，只有在它等待的承诺被解决后才返回并继续执行。

3.  使用`await`呼叫`getUsage`以获得用户的使用:

    ```
    const usage = await clientApi.getUsage(currentUser.id);
    ```

4.  使用`await`呼叫`getRate`为用户获取费率:

    ```
    const rate = await clientApi.getRate(currentUser.id);
    ```

5.  最后调用`return`检索`id`、`address`、`due`:

    ```
    return {
    ```

    ```
    id,
    ```

    ```
    address: currentUser.address,
    ```

    ```
    due: (rate * usage.reduce((prev, curr) => curr + prev)).toFixed(2)
    ```

    ```
    };
    ```

6.  将`calculateAll`函数写成`async`函数:

    ```
    async function calculateAll() {
    ```

    ```
    }
    ```

7.  调用`getUsers`时使用`await`，并将结果存储在`result`:

    ```
    const result = await clientApi.getUsers();
    ```

8.  Use a map array to create a list of promises and use `Promise.all` to wrap them. Then, should be use `await` on the promise returned by `Promise.all`:

    ```
    return await Promise.all(result.users.map((user) => calculate(user.id)));
    ```

    因为`await`将在任何承诺上工作，并将等待，直到值被解析，它也将等待我们的`Promise.all`。 解析后，将返回最终的数组。

9.  Call `calculate` on one of the users:

    ```
    calculate('DDW2AU').then(console.log)
    ```

    输出结果如下:

    ![Figure 8.45: Calling calculate on one of the users ](Images/C14587_08_45.jpg)

    ###### 图 8.45:呼叫计算对一个用户

10.  Call the `calculateAll` function:

    ```
    calculateAll().then(console.log)
    ```

    输出结果如下:

![Figure 8.46: Calling the calculateAll function ](Images/C14587_08_46.jpg)

###### 图 8.46:调用 calculateAll 函数

如你所见，当我们调用`async`函数时，我们可以将它们视为返回一个承诺的函数。

## 第 9 章:事件驱动编程和内置模块

### 活动 13:构建事件驱动模块

**方案**:

执行以下步骤来完成此活动:

1.  导入`events`模块:

    ```
    const EventEmitter = require('events');
    ```

2.  Create the `SmokeDetector` class that extends `EventEmitter` and set `batteryLevel` to `10`:

    ```
    class SmokeDetector extends EventEmitter {
    ```

    ```
        constructor() {
    ```

    ```
            super();
    ```

    ```
            this.batteryLevel = 10;
    ```

    ```
        }
    ```

    ```
    }
    ```

    在我们的构造函数中，因为我们扩展了`EventEmitter`类并赋值了一个自定义属性`batteryLevel`，所以我们需要在构造函数中调用`super`并将`batteryLevel`设置为`10`。

3.  Create a `test` method inside the `SmokeDetector` class that will test the battery level and emit a `low battery` message in the event that the battery is low:

    ```
    test() {
    ```

    ```
            if (this.batteryLevel > 0) {
    ```

    ```
                this.batteryLevel -= 0.1;
    ```

    ```
                if (this.batteryLevel < 0.5) {
    ```

    ```
                    this.emit('low battery');
    ```

    ```
                }
    ```

    ```
                return true;
    ```

    ```
            }
    ```

    ```
            return false;
    ```

    ```
        }
    ```

    我们的`test()`方法将检查电池水平，并发出一个`low battery`事件，当电池少于 0.5 单位。 我们也会在每次运行`test`方法时降低电池电量。

4.  Create the `House` class, which will store the instances of our event listeners:

    ```
    class House {
    ```

    ```
        constructor(numBedroom, numBathroom, numKitchen) {
    ```

    ```
            this.numBathroom = numBathroom;
    ```

    ```
            this.numBedroom = numBedroom;
    ```

    ```
            this.numKitchen = numKitchen;
    ```

    ```
            this.alarmListener = () => {
    ```

    ```
                console.log('alarm is raised');
    ```

    ```
            }
    ```

    ```
            this.lowBatteryListener = () => {
    ```

    ```
                console.log('alarm battery is low');
    ```

    ```
            }
    ```

    ```
        }
    ```

    ```
    }
    ```

    在课堂上，我们存储一些关于房子的信息。 我们还将这两个事件监听器函数存储为该对象的属性。 这样，当我们想要分离一个侦听器时，就可以使用函数引用来调用`removeListener`。

5.  Create an `addDetector` method in the `House` class. Here, we will attach the event listeners:

    ```
    addDetector(detector) {
    ```

    ```
            detector.on('alarm', this.alarmListener);
    ```

    ```
            detector.on('low battery', this.lowBatteryListener);
    ```

    ```
        }
    ```

    在这里，我们期望传入的检测器是一个`EventEmitter`。 我们将两个事件监听器附加到`detector`参数上。 当这些事件被触发时，它将调用对象内部的事件发射器。

6.  Create a `removeDetector` method, which will help us remove the alarm event listeners we attached previously:

    ```
    removeDetector(detector) {
    ```

    ```
            detector.removeListener('alarm', this.alarmListener);
    ```

    ```
            detector.removeListener('low battery', this.lowBatteryListener);
    ```

    ```
        }
    ```

    这里，我们使用函数引用和 alarm 参数来删除附加到侦听器上的侦听器。 一旦调用了这个，事件就不应该再调用我们的侦听器了。

7.  创建一个名为`myHouse`的`House`实例。 这将包含一些关于我们房子的样本信息。 它也将被用来监听事件从我们的烟雾探测器:
8.  创建一个名为`detector`:

    ```
    const detector = new SmokeDetector();
    ```

    的`SmokeDetector`实例
9.  将`detector`加入`myHouse`:

    ```
    myHouse.addDetector(detector);
    ```

10.  Create a loop to call the test function `96` times:

    ```
    for (let i = 0; i < 96; i++) {
    ```

    ```
        detector.test();
    ```

    ```
    }
    ```

    由于测试功能会降低电池电量，我们预计，如果我们调用它`96`次，将发出*低电池*报警。 这将产生以下输出:

    ![Figure 9.50: Low battery alarm emitted ](Images/C14587_09_50.jpg)

    ###### 图 9.50:低电量报警

11.  Emit an alarm on the `detector` object:

    ```
    detector.emit('alarm');
    ```

    下面是上述代码的输出:

    ![Figure 9.51: Alarm emitted for the detector object ](Images/C14587_09_51.jpg)

    ###### 图 9.51:探测器对象发出的警报

12.  从`myHouse`对象中移除`detector`:

    ```
    myHouse.removeDetector(detector);
    ```

13.  Test this to emit the alarms on the `detector`:

    ```
    detector.test();
    ```

    ```
    detector.emit('alarm');
    ```

    因为我们刚刚从我们的房子中删除了`detector`，我们应该看不到输出:

![Figure 9.52: Testing the emit alarms on the detector ](Images/C14587_09_52.jpg)

###### 图 9.52:测试探测器发出的警报

### 活动 14:Building a File Watcher

**方案**:

1.  导入`fs`、`events`:

    ```
    const fs = require('fs').promises;
    ```

    ```
    const EventEmitter = require('events');
    ```

2.  Create a `fileWatcher` class that extends the `EventEmitter` class. Use a `modify` timestamp to keep track of the file change.

    我们需要创建一个扩展`EventEmitter`的`FileWatcher`类。 它将把文件名和 delay 作为构造函数中的参数。 在构造函数中，我们还需要设置最后修改的时间和 timer 变量。 我们暂时将它们设置为未定义:

    ```
    class FileWatcher extends EventEmitter {
    ```

    ```
        constructor(file, delay) {
    ```

    ```
            super();
    ```

    ```
            this.timeModified = undefined;
    ```

    ```
            this.file = file;
    ```

    ```
            this.delay = delay;
    ```

    ```
            this.watchTimer = undefined;
    ```

    ```
        }
    ```

    ```
    }
    ```

    这是查看文件是否被更改的最基本方法。

3.  Create the `startWatch` method to start watching the changes on the file:

    ```
    startWatch() {
    ```

    ```
            if (!this.watchTimer) {
    ```

    ```
                this.watchTimer = setInterval(() => {
    ```

    ```
                    fs.stat(this.file).then((stat) => {
    ```

    ```
                        if (this.timeModified !== stat.mtime.toString()) {
    ```

    ```
                            console.log('modified');
    ```

    ```
                            this.timeModified = stat.mtime.toString();
    ```

    ```
                        }
    ```

    ```
                    }).catch((error) => {
    ```

    ```
                        console.error(error);
    ```

    ```
                    });
    ```

    ```
                }, this.delay);
    ```

    ```
            }
    ```

    ```
        }
    ```

    这里，我们使用`fs.stat`获取文件信息，并将修改时间与上次修改时间进行比较。 如果它们不相等，我们将在控制台中输出**修改的**。

4.  Create the `stopWatch` method to stop watching the changes on the file:

    ```
    stopWatch() {
    ```

    ```
            if (this.watchTimer) {
    ```

    ```
                clearInterval(this.watchTimer);
    ```

    ```
                this.watchTimer = undefined;
    ```

    ```
            }
    ```

    ```
           }
    ```

    `stopWatch`方法非常简单:我们将检查这个对象中是否有一个计时器。 如果我们这样做，那么我们运行`clearInterval`定时器来清除该定时器。

5.  在与`filewatch.js`相同的目录下创建一个`test.txt`文件。
6.  创建一个`FileWatcher`实例，并开始查看每一个`1000`ms:

    ```
    const watcher = new FileWatcher('test.txt', 1000);
    ```

    ```
    watcher.startWatch();
    ```

7.  Modify some content in `test.txt` and save it. You should see the following output:

    ![Figure 9.53: Output after modifying the content in the test.txt file ](Images/C14587_09_53.jpg)

    ###### 图 9.53:修改 test.txt 文件内容后的输出

    我们修改了该文件两次，这意味着我们看到了三条修改过的消息。 之所以会发生这种情况，是因为当我们开始监视时，我们将它类为正在修改的文件。

8.  Modify `startWatch` so that it also retrieves the new content:

    ```
    startWatch() {
    ```

    ```
            if (!this.watchTimer) {
    ```

    ```
                this.watchTimer = setInterval(() => {
    ```

    ```
                    fs.stat(this.file).then((stat) => {
    ```

    ```
                        if (this.timeModified !== stat.mtime.toString()) {
    ```

    ```
                            fs.readFile(this.file, 'utf-8').then((content) => {
    ```

    ```
                                console.log('new content is: ', content);
    ```

    ```
                            }).catch((error) => {
    ```

    ```
                                console.error(error);
    ```

    ```
                            });
    ```

    ```
                            this.timeModified = stat.mtime.toString();
    ```

    ```
                        }
    ```

    ```
                    }).catch((error) => {
    ```

    ```
                        console.error(error);
    ```

    ```
                    });
    ```

    ```
                }, this.delay);
    ```

    ```
            }
    ```

    ```
        }
    ```

    当我们修改`test.txt`并保存它时，我们的代码应该检测它并输出新的内容:

    ![Figure 9.54: The modifications that were made in the file can be seen using the startWatch function  ](Images/C14587_09_54.jpg)

    ###### 图 9.54:使用 startWatch 函数可以看到文件中所做的修改

9.  Modify `startWatch` so that it emits events when the file is modified and an error when it encounters an error:

    ```
    startWatch() {
    ```

    ```
            if (!this.watchTimer) {
    ```

    ```
                this.watchTimer = setInterval(() => {
    ```

    ```
                    fs.stat(this.file).then((stat) => {
    ```

    ```
                        if (this.timeModified !== stat.mtime.toString()) {
    ```

    ```
                            fs.readFile(this.file, 'utf-8').then((content) => {
    ```

    ```
                                this.emit('change', content);
    ```

    ```
                            }).catch((error) => {
    ```

    ```
                                this.emit('error', error);
    ```

    ```
                            });
    ```

    ```
                            this.timeModified = stat.mtime.toString();
    ```

    ```
                        }
    ```

    ```
                    }).catch((error) => {
    ```

    ```
                        this.emit('error', error);
    ```

    ```
                    });
    ```

    ```
                }, this.delay);
    ```

    ```
            }
    ```

    ```
        }
    ```

    我们将使用新内容发出一个事件，而不是输出内容。 这使得我们的代码更加灵活。

10.  `watcher`:

    ```
    watcher.on('error', console.error);
    ```

    ```
    watcher.on('change', (change) => {
    ```

    ```
        console.log('new change:', change);
    ```

    ```
    });
    ```

11.  运行代码并修改`test.txt`:

![Figure 9.55: Output after changing our file watcher ](Images/C14587_09_55.jpg)

###### 图 9.55:更改文件监视器后的输出

## 第十章:JavaScript 函数式编程

### 活动 15:onCheckout 回调道具

**溶液**

1.  将当前目录更改为`Lesson10`，并运行`npm install`(如果您以前未在此目录下运行)。 `npm install`下载运行此活动所需的依赖项(React 和 Parcel)。
2.  Run `parcel serve activity-on-checkout-prop-start.html` and then execute `npm run Activity15`. You will see the application starting up, as follows:

    ![Figure 10.42: Output after running the start html script ](Images/C14587_10_42.jpg)

    ###### 图 10.42:运行 start html 脚本后的输出

3.  Go to `http://localhost:1234` (or whichever URL the start script output). You should see the following HTML page:

    ![Figure 10.43: Initial application in the browser ](Images/C14587_10_43.jpg)

    ###### 图 10.43:浏览器中的初始应用程序

4.  The `onClick` of the **Proceed to checkout** can be implemented as follows:

    ```
      render() {
    ```

    ```
        return (
    ```

    ```
          <div>
    ```

    ```
            <p>You have {this.state.items.length} items in your basket</p>
    ```

    ```
            <button onClick={() => this.props.onCheckout(this.state.items)}>
    ```

    ```
              Proceed to checkout
    ```

    ```
            </button>
    ```

    ```
          </div>
    ```

    ```
        );
    ```

    ```
      }
    ```

    这是根据以下调查得出的结论:

    在`Basket`组件的`render`方法中找到文本为`Proceed to checkout`的按钮。

    注意到它的`onClick`处理器目前是一个在被调用时什么也不做的函数`() => {}`。

    用正确的`this.props.onCheckout`调用替换`onClick`处理程序。

5.  点击`Proceed to checkout`按钮可以看到:

![Figure 10.44: Output after clicking on the “Proceed to checkout” button ](Images/C14587_10_44.jpg)

###### 图 10.44:点击“Proceed to checkout”按钮后的输出

### 活动 16:测试选择器

**溶液**

1.  Run `npm run Activity16` (or `node activity-items-selector-test-start.js`). You will see the following output:

    ![Figure 10.45: Expected output after running the start file of the activity ](Images/C14587_10_45.jpg)

    ###### 图 10.45:运行活动的启动文件后的预期输出

2.  测试，对于空状态，选择器返回`[]`:

    ```
    function test() {
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems(),
    ```

    ```
        [],
    ```

    ```
        'should be [] when selecting with no state'
    ```

    ```
      );
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when selecting with {} state'
    ```

    ```
      );
    ```

    ```
    }
    ```

3.  测试，对于空的篮子对象，选择器返回[]:

    ```
    function test() {
    ```

    ```
      // other assertions
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({basket: {}}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when selecting with {} state.basket'
    ```

    ```
      );
    ```

    ```
    }
    ```

4.  测试，如果 items 数组设置为空，则选择器返回`[]:`

    ```
    function test() {
    ```

    ```
      // other assertions
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({basket: {items: []}}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when items is []'
    ```

    ```
      );
    ```

    ```
    }
    ```

5.  测试,如果`items`数组没有空和设置,选择器返回:

    ```
    function test() {
    ```

    ```
      // other assertions
    ```

    ```
      assert.deepStrictEqual(
    ```

    【4】【5】

    ```
        }),
    ```

    ```
        [{name: 'product-name'}],
    ```

    【显示】

    ```
      );
    ```

    ```
    }
    ```

    ```
    The full test function content after following the previous solution steps:
    ```

    【病人】

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems(),
    ```

    ```
        [],
    ```

    【t16.1】

    ```
      );
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when selecting with {} state'
    ```

    ```
      );
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({basket: {}}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when selecting with {} state.basket'
    ```

    ```
      );
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({basket: {items: []}}),
    ```

    ```
        [],
    ```

    ```
        'should be [] when items is []'
    ```

    ```
      );
    ```

    ```
      assert.deepStrictEqual(
    ```

    ```
        selectBasketItems({
    ```

    ```
          basket: {items: [{name: 'product-name'}]}
    ```

    ```
        }),
    ```

    ```
        [{name: 'product-name'}],
    ```

    ```
        'should be items when items is set'
    ```

    ```
      );
    ```

    ```
    }
    ```

6.  在执行的测试的输出中应该没有错误:

![Figure 10.46: Final output showing no errors ](Images/C14587_10_46.jpg)

###### 图 10.46:没有显示错误的最终输出

### 活动 17:从最好的朋友那里拿当前的篮子

**溶液**

1.  将当前目录更改为`Lesson10`，并运行`npm install`(如果您以前未在此目录下运行)。
2.  Run the BFF for Activity 17 and `npx parcel serve activity-app-start.html`. During development, run `npm run Activity17`. You will see the application starting up, as follows:

    ![Figure 10.47: Running the initial start file for the activity ](Images/C14587_10_47.jpg)

    ###### 图 10.47:运行活动的初始启动文件

3.  Go to `http://localhost:1234` (or whichever URL the starting script output). You should see the following HTML page:

    ![Figure 10.48: Initial application in the browser ](Images/C14587_10_48.jpg)

    ###### 图 10.48:浏览器中的初始应用程序

4.  Run the following query in the GraphiQL UI:

    ```
    {
    ```

    ```
      basket {
    ```

    ```
        items {
    ```

    ```
          id
    ```

    ```
          name
    ```

    ```
          price
    ```

    ```
          quantity
    ```

    ```
        }
    ```

    ```
      }
    ```

    ```
    }
    ```

    下面是上述代码的输出:

    ![Figure 10.49: GraphiQL UI with basket query ](Images/C14587_10_49.jpg)

    ###### 图 10.49:带有篮子查询的 graphhiql UI

5.  创建一个新的`requestBasket`动作创造者(利用 redux-thunk)。 它调用`fetchFromBff`前一步的查询和分派一个`REQUEST_BASKET_SUCCESS`动作与一篮子载荷提取 GraphQL 回应:

    ```
    function requestBasket() {
    ```

    【4】【5】

    ```
          basket {
    ```

    ```
            items {
    ```

    【显示】

    ```
              name
    ```

    ```
              price
    ```

    ```
              quantity
    ```

    【病人】

    ```
          }
    ```

    ```
        }`).then(data => {
    ```

    ```
          dispatch({
    ```

    【t16.1】

    ```
            basket: data.basket
    ```

    ```
          });
    ```

    ```
        });
    ```

    ```
      };
    ```

    ```
    }
    ```

6.  减少篮子数据存储和添加下面的案例`REQUEST_BASKET_SUCCESS``appReducer`来减少我们的新行动的`basket`有效载荷状态:

    ```
    const appReducer = (state = defaultState, action) => {
    ```

    【4】【5】

    ```
        case REQUEST_BASKET_SUCCESS:
    ```

    ```
          return {
    ```

    【显示】

    ```
            basket: action.basket
    ```

    ```
          };
    ```

    ```
        // other cases
    ```

    【病人】

    ```
    };
    ```

7.  在`mapDispatchToProps`中加入`requestBasket`，如下:

    ```
    const mapDispatchToProps = dispatch => {
    ```

    ```
      return {
    ```

    ```
        // other mapped functions
    ```

    ```
        requestBasket() {
    ```

    ```
          dispatch(requestBasket());
    ```

    ```
        }
    ```

    ```
      };
    ```

    ```
    };
    ```

8.  Call `requestBasket` on `componentDidMount`:

    ```
    class App extends React.Component {
    ```

    ```
      componentDidMount() {
    ```

    ```
        this.props.requestBasket();
    ```

    ```
      }
    ```

    ```
      // render method
    ```

    ```
    }
    ```

    当前面所有步骤都完成后，加载应用程序时，它会闪烁“你的篮子里有 0 项”的信息，然后切换到下面的截图。 当从 BFF 获取完成时，它被减少到存储中并导致重新渲染。 这将再次显示篮子，如下所示:

![Figure 10.50: Final application once it has been integrated with the BFF](Images/C14587_10_50.jpg)

###### 图 10.50:与 BFF 集成后的最终应用程序